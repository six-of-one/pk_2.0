/* ::-::
 *
 * Cataboligne
 *
 * file: pk_itm_dynamic.qc
 *
 * date: 
 *
 * qc - support painkeep 2.0 dynamic items
 *
 */


// these fn are used by most item control code

// fn(item_repm) - replace / remove all items matching with a new item
// fn(item_bit) - provide item classname string by bit
// fn(item_call) - make item call based on string
// fn(item_down) - item (self) is removed from play for this map till admin overrides removal or new map is loaded
// fn(item_loop) - run loop making changes per pk_itemovr
// rep - item classname to replace
// cls - new classname
// op - save original classname in .wad so we can restore if mode is turned off

string (float bt) item_by_bit =
{
	if (bt == WEP_SSHOT) return("weapon_supershotgun");
	if (bt == WEP_NAILGUN) return("weapon_nailgun");
	if (bt == WEP_PERF) return("weapon_supernailgun");
	if (bt == WEP_GREN) return("weapon_grenadelauncher");
	if (bt == WEP_ROCKET) return("weapon_rocketlauncher");
	if (bt == WEP_THUNDER) return("weapon_lightning");
	if (bt == WEP_PKI) return("pki");
	if (bt == ART_INV) return("item_artifact_invulnerability");
	if (bt == ART_RAD) return("item_artifact_envirosuit");
	if (bt == ART_RING) return("item_artifact_invisibility");
	if (bt == ART_QUAD) return("item_artifact_super_damage");
	if (bt == ARM_GRN) return("item_armor1");
	if (bt == ARM_YEL) return("item_armor2");
	if (bt == ARM_RED) return("item_armorInv");
	if (bt == HEAL_15) return("item_health_15");
	if (bt == HEAL_25) return("item_health");
	if (bt == HEAL_100) return("item_health_mega");

	return("");
};

// ammo for a given wep - used for replacements & pk items subs

string (float bt) ammo_by_bit =
{
// wep ammo by bit
	if (bt == WEP_SSHOT) return("item_shells");
	if (bt == WEP_NAILGUN) return("item_spikes");
	if (bt == WEP_PERF) return("item_spikes");
	if (bt == WEP_GREN) return("item_rockets");
	if (bt == WEP_ROCKET) return("item_rockets");
	if (bt == WEP_THUNDER) return("item_cells");
	if (bt == WEP_PKI) return("pki");

	if (Q_100 | Q_99) // Cataboligne - 8.16.9 - quake 1 compatability mode(s)
		return("");
	
// pk item subs by special bits
	if (bt == WEP_GWELL) return("item_painkeep_gwell");
	if (bt == WEP_TURRET) return("item_painkeep_turret");
	if (bt == WEP_BTRAP) return("item_painkeep_beartrap");
	if (bt == WEP_EXPSH) return("item_painkeep_expshells");
	if (bt == WEP_GRAP) return("weapon_grapgun");
	if (bt == WEP_AIRG) return("weapon_airfist");
	if (bt == WEP_CPNB) return("item_painkeep_can");

//	if (!PK_ART) return(""); // Cataboligne 8.12.9 purify - pk artifacts
// pk art item subs by special bits
	if (bt == WEP_EGO) return("item_pkplus_ego");
	if (bt == WEP_TOMB) return("item_pkplus_tomb");
	if (bt == WEP_ACTOR) return("item_pkplus_actor");
	if (bt == WEP_PHONE) return("item_pkplus_phone");

	return("");
};

void(string cls) item_call =
{
	local string scls;
	local float rd;

	rd = random();
	if (self.classname != "dyn_item") rd = 1;
	
	scls = cls;
	if (cls == "weapon_supershotgun") weapon_supershotgun();
	else if (cls == "weapon_nailgun") weapon_nailgun();
	else if (cls == "weapon_supernailgun") weapon_supernailgun();
	else if (cls == "weapon_grenadelauncher") weapon_grenadelauncher();
	else if (cls == "weapon_rocketlauncher") weapon_rocketlauncher();
	else if (self.classname == "dyn_item" && cls == "weapon_lightning")
	{
		if (PK) weapon_chainlg();
		else weapon_lightning();
	}
	else if (cls == "weapon_lightning") weapon_lightning();
	else if (cls == "item_shells") { if (rd < 0.5) self.spawnflags = WEAPON_BIG2; item_shells(); }
	else if (cls == "item_spikes") { if (rd < 0.4) self.spawnflags = WEAPON_BIG2; item_spikes(); }
	else if (cls == "item_rockets") { if (rd < 0.2) self.spawnflags = WEAPON_BIG2; item_rockets(); }
	else if (cls == "item_cells") { if (rd < 0.8) self.spawnflags = WEAPON_BIG2; item_cells(); }

	else if (cls == "item_shells_lg") { self.spawnflags = WEAPON_BIG2; item_shells(); scls = "item_shells"; }
	else if (cls == "item_spikes_lg") { self.spawnflags = WEAPON_BIG2; item_spikes(); scls = "item_spikes"; }
	else if (cls == "item_rockets_lg") { self.spawnflags = WEAPON_BIG2; item_rockets(); scls = "item_rockets"; }
	else if (cls == "item_cells_lg") { self.spawnflags = WEAPON_BIG2; item_cells(); scls = "item_cells"; }

	else if (cls == "item_artifact_invulnerability") item_artifact_invulnerability();
	else if (cls == "item_artifact_super_damage") item_artifact_super_damage();
	else if (cls == "item_artifact_envirosuit") item_artifact_envirosuit();
	else if (cls == "item_artifact_invisibility") item_artifact_invisibility();
	else if (cls == "item_armor1") item_armor1();
	else if (cls == "item_armor2") item_armor2();
	else if (cls == "item_armorInv") item_armorInv();
	else if (cls == "item_health_15") { self.spawnflags = H_ROTTEN; item_health(); scls = "item_health";}
	else if (cls == "item_health") item_health();
	else if (cls == "item_health_mega") { self.spawnflags = H_MEGA; item_health(); scls = "item_health"; }

	else if (cls == "item_key1") item_key1();
	else if (cls == "item_key2") item_key2();

	else if (cls == "item_sigil1") { self.spawnflags = rune_bit_code(MC_SIGIL1, 0); item_sigil(); scls = "item_sigil"; }
	else if (cls == "item_sigil2") { self.spawnflags = rune_bit_code(MC_SIGIL2, 0); item_sigil(); scls = "item_sigil"; }
	else if (cls == "item_sigil4") { self.spawnflags = rune_bit_code(MC_SIGIL4, 0); item_sigil(); scls = "item_sigil"; }
	else if (cls == "item_sigil8") { self.spawnflags = rune_bit_code(MC_SIGIL8, 0); item_sigil(); scls = "item_sigil"; }

//	else if (cls == "item_") item_();

	else if (cls == "item_painkeep_gwell") item_painkeep_gwell();
	else if (cls == "item_painkeep_turret") item_painkeep_turret();
	else if (cls == "item_painkeep_beartrap") item_painkeep_beartrap();
	else if (cls == "item_painkeep_expshells") item_painkeep_expshells();
	else if (cls == "weapon_chainlg") weapon_chainlg();
	else if (cls == "weapon_pulsenail") weapon_pulsenail();
	else if (cls == "weapon_grapgun") weapon_grapgun();
	else if (cls == "weapon_airfist") weapon_airfist();
	else if (cls == "item_painkeep_can") item_painkeep_can();
//	else if (!PK_ART) return; // Cataboligne 8.12.9 purify - pk artifacts
	else if (cls == "item_pkplus_ego") item_pkplus_ego();
	else if (cls == "item_pkplus_tomb") item_pkplus_tomb();
	else if (cls == "item_pkplus_actor") item_pkplus_actor();
	else if (cls == "item_pkplus_phone") item_pkplus_phone();
	else return;
	self.mdl = self.model;
	self.flags = FL_ITEM;
	self.movetype = MOVETYPE_TOSS;
	if (self.classname != "dyn_item") // dont do these for dyn items
	{
		self.classname = scls;
		pk_placeitem();
		self.think = SUB_regen; // dont go thru place_item - use regen method
		self.nextthink = time + 1 + 3 * random(); // spread em out
		self.model = string_null;
	}
	if (self.map  == "rune") self.delay = 0; 
	self.solid = SOLID_NOT;
//	bot_item_linx(self); // *bot - item tie in - needs checked for use here -- FIX
};

// this section implements admin override of map items, remove (& replace), cycle & inf ammo

void() item_down =
{
	self.model = "";
	self.touch = SUB_Null;
	self.solid = SOLID_NOT;
};

void(string cls, string rep, string am, string ram) item_repm =
{
	local entity e, sv;
	local string pam;
	local float f;

	if (!find(world,wad,rep))
	{
		e = find(world,classname,rep);
		if (!e) return;
		while (e)
		{
			if (e.wad == "") e.wad = e.classname;
			e = find(e,classname,rep);
		}
	}
	pam = am;
	if (pk_itemovr & CON_INF) pam = "rem"; // inf ammo
	if (pk_itemovr & WEP_PKI)
	{
		f = WEP_STOP * ceil(2 * random()) * ceil(2 * random()) * ceil(2 * random());
		if (pk_itemovr & CON_INF) pam = "pki"; // inf ammo - pk item subs
	}
	sv = self;
	e = find(world,wad,rep);
	while (e)
	{
		self = e;
		if (cls == "rest")
		{
			item_call(rep);
			if (ram != "")
			{
bprint("repm: item_repm internal - rest -- rem | pki replace or restore\n");
				if (pam == "rem" || pam == "pki") item_repm(pam, ram, "", "");
				else item_repm("rest", ram, "", "");
			}
		}
		else if (cls == "" || cls == "pki" || cls == "rem")
		{
			if ((pk_itemovr & WEP_PKI) && PK && cls == "pki")
			{
				f = f * 2;
				if (f > WEP_CPNB) f = WEP_GWELL;
				item_call(ammo_by_bit(f)); // TDO: finish item call
			}
			else
				item_down();
bprint("repm: restore on -:-, pki or rem --- ram != pam\n");
			if (ram != "")
			if (ram != pam) item_repm(pam, ram, "", "");
		}
		else
		{
			item_call(cls);
bprint("repm: restore on end else --- ram != pam\n");
			if (ram != "")
			if (ram != pam) item_repm(pam, ram, "", "");
		}
		e = find(e,wad,rep);
	}
	self = sv;
};

// main loop handles admin item override

void() item_loop =
{
	local float f, e, d, pko, pks, sf, lvl, lvls, msk;
	local string cl;

	pks = 0;
	lvls = f = 1;
	e = lvl = WEP_STOP;

	while (f != CON_STOP)
	{
		pko = pk_itemovr;
		if (pko & CON_CYC)
		{
			sf = 2;
			msk = (lvl - 1) - (lvls - 1);
			f = self.cnt = self.count & msk;
			if (!f) f = self.cnt = lvls;
			else f = self.cnt = self.cnt * 2;
			if (f == lvl) f = self.cnt = lvls;
			while (sf > 0 && !(f & pk_itemovr))
			{
				f = self.cnt = self.cnt * 2;
				if (f == lvl) // loop once
				{
					f = self.cnt = lvls;
					sf = sf - 1;
				}
			}
			if (sf < 1) f = lvl;
			else
			{
				pko = f | CON_ONLY | CON_CYC;// | pko - (pko & (CON_NONE | CON_SUBS));
				pks = pks | f;
			}
		}
		else if (pko & CON_SUBS) // find a valid substitute code
		{
			e = floor(e / 2);
			if (e < lvls) e = lvl / 2;
			sf = 7;
			while ((e & pko) && e >= lvls && sf > 0)
			{
				e = floor(e / 2);
				sf = sf - 1;
			}
			if (e < lvls || sf < 1) pko = pko - (pko & CON_SUBS); // cant sub if no sub item - can this happen?
		}

	if (f != lvl)
	{
		if (! (pko & CON_RUN))
		{
bprint("repm: restore on no con_run\n");
			item_repm("rest", item_by_bit(f), "", ammo_by_bit(f)); // restore
//			return;
		}
		else if (f & pko) // bit active
		{
			if (pko & CON_ONLY)
			{
				for (e = lvls;e < lvl; e = e * 2)
				{
					cl = item_by_bit(f);
//					if (e != f)//{
bprint("repm: restore on con_only\n");
					item_repm(cl, item_by_bit(e), ammo_by_bit(f), ammo_by_bit(e));

				}
			}
			else if (pko & CON_NONE)
			{
				cl = item_by_bit(e);
	bprint("repm: restore on con_none - con_subs or else\n");
			if (pko & CON_SUBS) item_repm(cl, item_by_bit(f), ammo_by_bit(e), ammo_by_bit(f));
				else item_repm("", item_by_bit(f), "", ammo_by_bit(f));
			}
			else if (pko & CON_INF) { bprint("repm: restore on rest - con_inf\n");

				item_repm("rest", item_by_bit(f), "", ammo_by_bit(f)); }
		}
		if (pko & CON_CYC) f = lvl;
		else f = f * 2;
	}
		if (f == lvl)
		{
//			if (lvl < CON_STOP)
//			{
//				e = lvl = CON_STOP;
//				f = lvls = ART_QUAD;
//			}

			if (lvl < ART_STOP)
			{
				e = lvl = ART_STOP;
				f = lvls = ART_QUAD;
			}
			else if (lvl < ARM_STOP)
			{
				e = lvl = ARM_STOP;
				f = lvls = ARM_GRN;
			}
			else if (lvl < HEAL_STOP)
			{
				e = lvl = HEAL_STOP;
				f = lvls = HEAL_15;
			}
		}
	}
	if (pk_itemovr & CON_CYC) // next item cycle
	{
		self.nextthink = time + CYC_TIME + crandom() * CYC_TIME;
		self.count = pks; // next cycle starts at these items
	}
	else
		remove(self);
};

// fn(ammo_con) - handle admin infinite flag, runes, chaos, etc

// NOTE: need to sw to inf ammo wep if ammo = 0

float(float cn, entity e, string op) ammo_con =
{
	float f;

	f = cn;

	if (Q_100 || PK_100) return(f);

	if (op == "") // operation not specced - assume 0 cn if inf or ...
	{
		if (pk_itemovr & CON_INF)
		{
		if (e.weapon == IT_SUPER_SHOTGUN)
		if (pk_itemovr & WEP_SSHOT) f = 0;

		if (e.weapon == IT_NAILGUN)
		if (pk_itemovr & WEP_NAILGUN) f = 0;

		if (e.weapon == IT_SUPER_NAILGUN)
		if (pk_itemovr & WEP_PERF) f = 0;

		if (e.weapon == IT_GRENADE_LAUNCHER)
		if (pk_itemovr & WEP_GREN) f = 0;

		if (e.weapon == IT_ROCKET_LAUNCHER)
		if (pk_itemovr & WEP_ROCKET) f = 0;

		if (e.weapon == IT_LIGHTNING || e.pk_currentitem == PK_IT_CLIGHT)
		if (pk_itemovr & WEP_THUNDER) f = 0;
		}
	}
	else if (op == "ldck") // load check - allow sw to inf ammo wep
	{
		if (e)
		if (pk_itemovr & CON_INF)
		{
		if (pk_itemovr & WEP_SSHOT)
		if (e.ammo_shells < 2) e.ammo_shells = 2;

		if (pk_itemovr & WEP_NAILGUN)
		if (e.ammo_nails < 1) e.ammo_nails = 1;

		if (pk_itemovr & WEP_PERF)
		if (e.ammo_nails < 2) e.ammo_nails = 2;

		if (pk_itemovr & WEP_GREN)
		if (e.ammo_rockets < 1) e.ammo_rockets = 1;

		if (pk_itemovr & WEP_ROCKET)
		if (e.ammo_rockets < 1) e.ammo_rockets = 1;

		if (pk_itemovr & WEP_THUNDER)
		if (e.ammo_cells < 2) e.ammo_cells = 2;
		}
	}

	return(f);
};

// this section makes dynamic items by admin or map fn

// fn(dyn_spawn) - create an item
// fn(dyn_rem) - remove a dynamic item after a timeout
// fn(dyn_rndloc) - get a random location to spawn an item dynamically

void() dyn_rem =
{
	remove(self.enemy);
	remove(self);
	pk_ditems = pk_ditems - 1;
}

entity rseu; // random spawn ent origin used

// returns a "near" entity to use its origin - this is really the only safe way to pick a random location within a map

entity() dyn_rndloc =
{
	float ri, sf;
	local entity e, sv;

	ri = sf = 0;
	sv = e = find(world,classname,"player");
	while (e)
	{
		sv = e;
		e = find(e,classname,"player");
	}
	e = findradius(sv.origin, PK_DYNRAD);
	if (!e) return(world); // nothing found!
	sv = e;
	while (e.chain) // count stuff for a random location selection from all these items found in range
	{
		if (!e.chain) e = world;
		else if (e.chain.flags & FL_ITEM) { ri = ri + 1; e = e.chain; }
		else if (e.chain.classname == "info_player_deathmatch") { ri = ri + 1; e = e.chain; }
		else if (e.chain.classname == "info_teleport_destination") { ri = ri + 1; e = e.chain; }
		else if (e.chain.classname == "path_corner") { ri = ri + 1; e = e.chain; }
		else if (e.chain.classname == "hub_custom") { ri = ri + 1; e = e.chain; }
//		else if (e.chain.classname == "") { ri = ri + 1; e = e.chain; }
		else e.chain = e.chain.chain; // skipper!
	}
	e = sv;
	sf = ri * random(); // pick a random ent from list - idea: prioritize away from weps?
	while (sf > 0 && e)
	{
		if (rseu == e && ri > 2) { sf = sf - 1; e = e.chain; } // skipper!
		if (e) sv = e;
		e = e.chain;
		sf = sf - 1;
	}
	rseu = sv;
	return(sv);
};

// some deviation around a random loc, rule out solid areas

vector(vector v1, float d1, float r1) stdv_rndloc =
{
	vector v2;
	local float sf, pco, f, k;

	v2 = v1;
	sf = 500;
	pco = CONTENT_SOLID;

	while (sf > 0 && pco == CONTENT_SOLID)
	{
		f = crandom() * r1;
		k = d1;
		if (f < 0) k = 0 - d1;
		v2_x = v1_x + k + f;
		f = crandom() * r1;
		k = d1;
		if (f < 0) k = 0 - d1;
		v2_y = v1_y + k + f;
		pco = pointcontents(v2);
		sf = sf - 1;
		if (sf < 1) v2 = v1;
	}
	return(v2);
};

void() dyn_spawn =
{
	local entity sv;

// get a random origin
  if (self.origin == v0)
  {
		sv = dyn_rndloc();
		if (!sv) sv = findradius(world.origin, 256000);
		if (!sv) return; // nothing found!
		setorigin(self, sv.origin + ' 0 0 16');
  }
  else
  {
		sv = findradius(self.origin, PK_DYNRAD);
  }
// give players notice
	bprint("*** Dynamic item spawned: ");
	bprint(self.wad);
	if (sv)
	{
		bprint(" near: ");
		bprint(sv.classname);
	}
	else
		bprint(" on the map");
	bprint("\n");

	item_call(self.wad);
	sv = spawn();
	sv.enemy = self;
	sv.think = dyn_rem;
	sv.nextthink = time + PK_DYNTO + crandom() * 55;
};

// think to handle dynamic item spawns if enabled by admin

void() dyn_item =
{
	float cd, f, b;
	entity e;

	if (PK_100 || Q_100 || !(pk_flags & PK_DYNAMIC || DYN_OVR || DYN_FORCE || DYN_ARTFR)) // Cataboligne - 8.15.9 - pk compat mode, just in case
	{
//		bprint("*** Warning - dynamic items deactivated\n");
		remove(self);
		return;
	}

	if (self.classname != "dyn_spawner")
	{
		self.classname = "dyn_spawner";
		self.nextthink = time + 7;// TEST 40 + 20 * crandom(); // PIC_TO
		self.count = 4 + 4 * random();
		if (DYN_FORCE || DYN_ARTFR_ONLY) self.count = pk_ditems + DYN_FORCE_CNT;
		if (!DYN_FORCE && !DYN_ARTFR && pk_ditems > 6) remove(self);
		else
		{
			if ((pk_flags & PK_DYNAMIC) || DYN_OVR)
			if (DYN_FORCE || DYN_ARTFR_ONLY)
			{
				bprint("*** Warning - dynamic items: force flags overlap normal flags, items may not spawn!\n");
				return;
			}
			bprint("***   Dynamic items will spawn on this map - keep an eye out\n");
		}
	}
// deprecated for remover above
//	else if (!DYN_FORCE && !DYN_ARTFR_ONLY)
//	{		
//		if (!PK || (!(pk_flags & PK_DYNAMIC) && !DYN_OVR)) // got turned off go away
//			remove(self);
//	}
	else
	{
	if (pk_ditems < 0) pk_ditems = 0;
	if (pk_ditems < self.count)
	 {
		cd = 1 + 2 * random();
		while (cd > 0.2)
		{
			e = spawn();
			e.origin = v0; // use random locator
			if (e)
			{
				e.think = dyn_spawn;
				e.nextthink = 3 + 12 * random(); // time spread
				e.classname = "dyn_item";
				b = 7;
				f = 6.4; // painkeep items bits (7 - 13) = 128 - 8192
				if (DYN_ART || DYN_ARTFR) f = 10.4; // add in (14 - 17) 16384 - 131072
				if (DYN_ARTFR_ONLY) // only (14 - 17) 16384 - 131072
				{
					b = 14;
					f = 3.4;
				}
				e.cnt = AdminBitFlag(floor(b + f * random())); // item to spawn
				e.wad = ammo_by_bit(e.cnt); // classname to spawn
				if (random() < 0.027)  // small chance of clg + ammo
				{
					e.wad = "weapon_lightning";
					e = world;
					e = spawn();
					if (e)
					{
						e.think = dyn_spawn;
						e.nextthink = 1 + 4 * random();
						e.classname = "dyn_item";
						e.wad = "item_cells";
					}
					e = spawn();
					if (e)
					{
						e.think = dyn_spawn;
						e.nextthink = 1 + 4 * random();
						e.classname = "dyn_item";
						e.wad = "item_cells";
					}
				}
//				pk_ditems = pk_ditems + 1; // done in spawn
			}
			cd = cd - 1;
		}
	 }
	self.nextthink = time + 40 + 20 * crandom();
	}
};

// fn(func_dynitem) - map load dynamic item ent maker

// wait - time between spawns in secs
// delay - random deviation, neg (-) number uses crandom, randomize spawn time of item
// lip - range from origin to spawn items in quake units
// spawnflags & 1 - uses func_dyn location, if 0, randomize
// spawnflags & 2 - spawn random ammo for weps loaded by fn - uses dyn_spawn locator code
// dest1 - weapon bit codes to select from
// dest2 - item bit codes to select from

// pk_dyn_func_stop - stop func_dynitem processing

void() func_dynitem =
{
	local float rv, sb;
	local entity e;
	local vector v1;

	if (PK_100 || Q_100)
	{
	remove(self);
	return;
	}

// clear any of this
	self.solid = SOLID_NOT;
	self.movetype = MOVETYPE_NONE;
	self.modelindex = 0;

// loop
	if (self.delay < 0) rv = crandom() * fabs(self.delay);
	else rv = random() * self.delay;

	self.think = func_dynitem;
	self.nextthink = time + self.wait + rv;

// stop item spawn when set true - leaves func_ ents on map
	if (cvar("pk_dyn_func_stop")) return;

	if (time < PIC_TO) return;

// spawn an item
	e = spawn();
	if (e)
	{
		e.think = dyn_spawn;
		e.nextthink = 1 + self.delay * random(); // time spread -- FIX - get rid of neg number
		e.classname = "dyn_item";

		if (self.spawnflags & 1) // cheat this - just use x,y coord
		{
			local float sf;
			sf = 100;
			v1_z = self.origin_z;
			v1_x = self.origin_x + crandom() * self.lip;
			v1_y = self.origin_y + crandom() * self.lip;
			while (pointcontents(v1) == CONTENT_SOLID && sf > 0) // IDEA - check lava below?
			{
				sf = sf - 1;
				v1_x = self.origin_x + crandom() * self.lip;
				v1_y = self.origin_y + crandom() * self.lip;
			}
			if (sf < 0) v1 = self.origin;
			setorigin(e, v1);
		}
		else
			setorigin(e, v0);
		if (self.dest1_x)
		{
			sb = e.cnt = bit_cnt(self.dest1_x, TRUE);
			e.wad = item_by_bit(e.cnt); // classname to spawn
			if ((self.spawnflags & 2) && (e.cnt & WEP_WEPSQ)) // make ammo for weps if spawnflags bit 2 set
			{
				rv = 1 + floor(random() * 3);
				while (rv > 0)
				{
					rv = rv - 1;
					e = world;
					e = spawn();
					if (e)
					{
						e.think = dyn_spawn;
						e.nextthink = 1 + 4 * random();
						e.classname = "dyn_item";
						e.cnt = sb;
						e.wad = ammo_by_bit(sb);
						e.origin = v0; // these can be anywhere
					}
				}
			}
		}
		else if (self.dest2_x)
		{
			e.cnt = bit_cnt(self.dest2_x, TRUE);
			e.wad = ammo_by_bit(e.cnt); // classname to spawn
		}
	}
};

// randomize any item

void() rndize_item;
void() place_item_control;

// rndize with no loop & need restore checks on active items

void() rndize_restore =
{
	self.nextthink = time + 10 + random() * 10;
	if (cvar("pk_place_item") != 2)
	{
		self.nextthink = time + 0.1;
		self.think = rndize_item;
	}
};

void() rndize_item =
{
	local entity e;
	local float sf;

	if (self.owner.mcode < MC_Q1)
		self.owner.mcode = 102 + rint(random() * 30);
	else if (self.owner.mcode < MC_PK)
		self.owner.mcode = 141 + rint(random() * 12); // TDO: should resp !pk_art 

	sf = 100;
	if (RUNES)
	while (self.owner.mcode >= MC_SIGIL1 && self.owner.mcode <= MC_SIGIL8 && sf > 0) // runes dont allow runes to be made here
	{
		self.owner.mcode = 102 + rint(random() * 30);
		sf = sf - 1;
		if (sf < 1) self.owner.mcode = self.owner.scode; // fail
	}

	self.owner.wad = item_by_mcode(self.owner.mcode);
	e = self;
	self = self.owner;
	self.pk_touch = (void()) 0; // so we can touch the new things

// TDO: chaos mod vector here
	e.cnt = cvar("pk_place_item_reload"); // randomize every so often

//	bprint("*** rndize item: ");
	if (cvar("pk_place_item") == 0)
	{
//		bprint("admin turned off & exiting randomize items & restoring\n");
		self.wad = item_by_mcode(self.scode);
		remove(e);
		pic_tsk = 0;
	}
	else
	if (cvar("pk_place_item") == 1)
	{
		place_item_control();
		remove(e);
		return;
	}
	else
	{
		if (!e.cnt)
		{
			e.nextthink = time + 10 + random() * 10;
			e.think = rndize_restore;
		}
		else
			e.nextthink = time + fabs(e.cnt) + random() * e.cnt;
	}
//	bprint(self.classname);
//	bprint(" is now: ");
//	bprint(self.wad);
//	bprint("\n");

	item_call(self.wad);
};

void() pic_restore_item =
{
	self.nextthink = time + 10 + random() * 10;
	if (cvar("pk_place_item") == 0)
	{
		pic_tsk = 0;
		self.wad = item_by_mcode(self.scode);
		item_call(self.wad);
	}
	else
	if (cvar("pk_place_item") == 2)
	{
		place_item_control();
	}
};

// Called by place item under specific conditions for map load

void() place_item_control =
{
	if (self.classname == "dyn_item")
		return;

	if(self.map == "") self.map = "pic_item";

	if (cvar("pk_place_item") == 1)
	{
		pic_tsk = 1;
		self.modelindex = 0;
		self.touch = SUB_Null;
		self.think = pic_restore_item;
		self.nextthink = time + 10 + random() * 10;
		return;
	}
	else if (cvar("pk_place_item") == 2)
	{
		local entity e;
		e = spawn();
		if (e)
		{
			e.owner = self;
			e.think = rndize_item;
			e.nextthink = time + 5 + random() * 2;
			e.classname = "rndize_item";
		}
		pic_tsk = 2;
	}
};

// twiddled after map load

void() place_item_control_loop =
{
	local entity e, sv;

	sv = self;
	e = find(world,map,"pic_item");
	while (e)
	{
		self = e;
		place_item_control();
		e = find(e,map,"pic_item");
	}
	self = sv;
};